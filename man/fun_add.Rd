% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add_fun.R
\name{fun_add}
\alias{fun_add}
\title{Add function}
\usage{
fun_add(p, fun, samples = NULL, closed = FALSE, color = NULL,
  type = NULL, tip = FALSE, secants = NULL, derivative = NULL)
}
\arguments{
\item{p}{Plot as initialised by \code{\link{funplot}}.}

\item{fun}{Function to plot.}

\item{samples}{Determine the number of equally spaced points
in which the function will be evaluated in the current domain,
increasing it will more accurately represent the function using rectangles
at the cost of processing speed.}

\item{closed}{Set to \code{TRUE} to render a closed path, y0 will always be 0 and y1 will be \eqn{fn(x)}.}

\item{color}{color.}

\item{type}{three representations of functions, default to \code{interval}, see details.}

\item{tip}{set to \code{TRUE} to hide the tooltip.}
}
\description{
Add a function to plot.
}
\details{
Valid \code{type} values:
\itemize{
  \item{\code{polyline} }{where \eqn{f(x)} is evaluated with some \eqn{x} values,
  after the evaluation the points are joined with line segments using \code{<path>}s}
  \item{\code{scatter} }{where \eqn{f(x)} is evaluated with some \eqn{x} values,
  after the evaluation the points are represented by \code{<circle>}s}
  \item{\code{interval} }{where \eqn{f(x)} is evaluated with intervals instead of a single point,
  after the evaluation 2d rects are painted on the screen (done using the \code{<path>} svg element)}
}

\code{fun}

Plotting roots can be a challenging problem, most plotters will actually analyze expression of the type \eqn{x^{a/b}},
particularly they will analyze the denominator of the exponent (to plot in the negative x-axis),
interval-arithmetic and math.js come bundled with a useful \code{nthRoot} function to solve these issues.

If a data object has a secants \code{list}, then each object will be used to compute secant lines between two
points belonging to the function, additionally if \code{updateOnMouseMove} is a property set to true in the object then
\eqn{(x_{0},f(x_{1}))} will be used as an anchored point and \eqn{(x_{0},f(x_{1}))} will be computed dynamically
based on the mouse abscissa.

Values for \code{secants} list:
\itemize{
  \item{\code{x0} }{the abscissa of the first point}
  \item{\code{x1} }{(optional if \code{updateOnMouseMove} is set) the abscissa of the second point}
  \item{\code{updateOnMouseMove} }{ (optional) if set to \code{TRUE} \code{x1} will be computed dynamically
  based on the current position of the mouse}.
}
}
\examples{
funplot() \%>\%
  fun_add(fun = "sin(x)")

# multiple functions
funplot() \%>\%
  fun_add("sqrt(1 - x * x)") \%>\%
  fun_add("-sqrt(1 - x * x)")

# samples
funplot() \%>\%
  fun_add(fun = "sin(x)", samples = 1000)

# closed = TRUE
funplot() \%>\%
  fun_add("1/x * cos(1/x)", closed = TRUE) \%>\%
  fun_x("log", domain = list(0.01, 1)) \%>\%
  fun_y(domain = list(-100, 100))

# color and type
funplot() \%>\%
  fun_add("x", color = "black") \%>\%
  fun_add("-x") \%>\%
  fun_add("-sqrt(x)", type = "scatter", samples = 100) \%>\%
  fun_add("sqrt(x)", tip = TRUE)

# nthRoot
funplot() \%>\%
  fun_add("nthRoot(x, 3)^2")

# secants
funplot() \%>\%
  fun_add(
    "x^2",
    secants = list(
      list(x0 = 2, x1 = 3),
      list(x0 = -2, updateOnMouseMove = TRUE),
      list(x0 = 1, x1 = 2)
    )
  ) \%>\%
  fun_y(domain = list(-200, 400)) \%>\%
  fun_x(domain = list(-300, 300))

# derivative
funplot() \%>\%
  fun_add("x^2", derivative = list(fn = "2 * x", updateOnMouseMove = TRUE))

}
\seealso{
\code{\link{fun_secants}}, \code{\link{fun_deriv}}
}
